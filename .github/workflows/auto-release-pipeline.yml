name: Auto Release Pipeline

on:
  push:
    branches:
      - main
      - master

permissions:
  contents: write
  packages: write

jobs:
  release-pipeline:
    runs-on: ubuntu-latest
    # è·³è¿‡ç”±GitHub Actionsåˆ›å»ºçš„æäº¤ï¼Œé¿å…æ­»å¾ªç¯
    if: github.event.pusher.name != 'github-actions[bot]' && !contains(github.event.head_commit.message, '[skip ci]')
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Check if version bump is needed
      id: check
      run: |
        # æ£€æµ‹æ˜¯å¦æ˜¯åˆå¹¶æäº¤
        PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
        PARENT_COUNT=$((PARENT_COUNT - 1))
        echo "Parent count: $PARENT_COUNT"

        if [ "$PARENT_COUNT" -gt 1 ]; then
          # åˆå¹¶æäº¤ï¼šè·å–åˆå¹¶è¿›æ¥çš„æ‰€æœ‰æ–‡ä»¶å˜æ›´
          echo "Detected merge commit, getting all merged changes"
          # è·å–åˆå¹¶åŸºå‡†ç‚¹
          MERGE_BASE=$(git merge-base HEAD^1 HEAD^2 2>/dev/null || echo "")
          if [ -n "$MERGE_BASE" ]; then
            # è·å–ä»åˆå¹¶åŸºå‡†åˆ° HEAD çš„æ‰€æœ‰å˜æ›´
            CHANGED_FILES=$(git diff --name-only $MERGE_BASE..HEAD)
          else
            # å¦‚æœæ— æ³•è·å–åˆå¹¶åŸºå‡†ï¼Œä½¿ç”¨ç¬¬äºŒä¸ªçˆ¶æäº¤
            CHANGED_FILES=$(git diff --name-only HEAD^2..HEAD)
          fi
        else
          # æ™®é€šæäº¤ï¼šè·å–ç›¸å¯¹äºä¸Šä¸€ä¸ªæäº¤çš„å˜æ›´
          CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD 2>/dev/null || git diff --name-only $(git rev-list --max-parents=0 HEAD)..HEAD)
        fi

        echo "Changed files:"
        echo "$CHANGED_FILES"

        # æ£€æŸ¥æ˜¯å¦åªæœ‰æ— å…³æ–‡ä»¶ï¼ˆ.md, docs/, .github/ç­‰ï¼‰
        SIGNIFICANT_CHANGES=false
        while IFS= read -r file; do
          # è·³è¿‡ç©ºè¡Œ
          [ -z "$file" ] && continue

          # æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦å¿½ç•¥çš„æ–‡ä»¶
          if [[ ! "$file" =~ \.(md|txt)$ ]] &&
             [[ ! "$file" =~ ^docs/ ]] &&
             [[ ! "$file" =~ ^\.github/ ]] &&
             [[ "$file" != "VERSION" ]] &&
             [[ "$file" != ".gitignore" ]] &&
             [[ "$file" != "LICENSE" ]]; then
            echo "Found significant change in: $file"
            SIGNIFICANT_CHANGES=true
            break
          fi
        done <<< "$CHANGED_FILES"

        if [ "$SIGNIFICANT_CHANGES" = true ]; then
          echo "Significant changes detected, version bump needed"
          echo "needs_bump=true" >> $GITHUB_OUTPUT
        else
          echo "No significant changes, skipping version bump"
          echo "needs_bump=false" >> $GITHUB_OUTPUT
        fi

    - name: Get current version
      if: steps.check.outputs.needs_bump == 'true'
      id: get_version
      run: |
        # è·å–æœ€æ–°çš„tagç‰ˆæœ¬
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        TAG_VERSION=${LATEST_TAG#v}

        # è·å–VERSIONæ–‡ä»¶ä¸­çš„ç‰ˆæœ¬
        FILE_VERSION=$(cat VERSION | tr -d '[:space:]')
        echo "VERSION file: $FILE_VERSION"

        # æ¯”è¾ƒtagç‰ˆæœ¬å’Œæ–‡ä»¶ç‰ˆæœ¬ï¼Œå–è¾ƒå¤§å€¼
        function version_gt() { test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"; }

        if version_gt "$FILE_VERSION" "$TAG_VERSION"; then
          VERSION="$FILE_VERSION"
          echo "Using VERSION file: $VERSION (newer than tag)"
        else
          VERSION="$TAG_VERSION"
          echo "Using tag version: $VERSION (newer or equal to file)"
        fi

        echo "Current version: $VERSION"
        echo "current_version=$VERSION" >> $GITHUB_OUTPUT

    - name: Calculate next version
      if: steps.check.outputs.needs_bump == 'true'
      id: next_version
      run: |
        VERSION="${{ steps.get_version.outputs.current_version }}"

        # åˆ†å‰²ç‰ˆæœ¬å·
        IFS='.' read -r -a version_parts <<< "$VERSION"
        MAJOR="${version_parts[0]:-0}"
        MINOR="${version_parts[1]:-0}"
        PATCH="${version_parts[2]:-0}"

        # é»˜è®¤é€’å¢patchç‰ˆæœ¬
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

        echo "New version: $NEW_VERSION"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Update VERSION file
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        echo "${{ steps.next_version.outputs.new_version }}" > VERSION

        # é…ç½®git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # æäº¤VERSIONæ–‡ä»¶ - æ·»åŠ  [skip ci] ä»¥é¿å…å†æ¬¡è§¦å‘
        git add VERSION
        git commit -m "chore: sync VERSION file with release ${{ steps.next_version.outputs.new_tag }} [skip ci]"

    # ç”Ÿäº§çº§ç¼“å­˜ä¼˜åŒ–å’Œæ€§èƒ½ç›‘æ§ç³»ç»Ÿ
    - name: Advanced Cache Management and Performance Monitoring Setup
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        echo "ğŸš€ å¯åŠ¨é«˜çº§ç¼“å­˜ç®¡ç†å’Œæ€§èƒ½ç›‘æ§ç³»ç»Ÿ"

        # åˆ›å»ºæ€§èƒ½ç›‘æ§ç›®å½•
        mkdir -p .github/performance-reports
        mkdir -p .github/cache-reports

        # æ€§èƒ½ç›‘æ§å¼€å§‹æ—¶é—´
        PERF_START=$(date +%s)
        echo "PERF_START=$PERF_START" >> $GITHUB_ENV

        # ç³»ç»Ÿæ€§èƒ½åŸºçº¿æµ‹é‡
        echo "ğŸ“Š æµ‹é‡ç³»ç»Ÿæ€§èƒ½åŸºçº¿..."

        # CPUä¿¡æ¯
        CPU_INFO=$(lscpu | grep "Model name" | sed 's/Model name:[[:space:]]*//')
        echo "CPU_INFO=$CPU_INFO" >> $GITHUB_ENV

        # å†…å­˜ä¿¡æ¯
        MEMORY_INFO=$(free -h | grep "Mem:" | awk '{print $2}')
        echo "MEMORY_INFO=$MEMORY_INFO" >> $GITHUB_ENV

        # ç£ç›˜ç©ºé—´
        DISK_AVAILABLE=$(df -h . | tail -1 | awk '{print $4}')
        echo "DISK_AVAILABLE=$DISK_AVAILABLE" >> $GITHUB_ENV

        # ç½‘ç»œå»¶è¿Ÿæµ‹è¯•
        NETWORK_LATENCY=$(ping -c 3 registry.npmjs.org | tail -1 | awk -F'/' '{print $5}' 2>/dev/null || echo "0")
        echo "NETWORK_LATENCY=$NETWORK_LATENCY" >> $GITHUB_ENV

        # åˆ›å»ºæ€§èƒ½åŸºçº¿æŠ¥å‘Š
        cat > .github/performance-reports/system-baseline.md << EOF
        # System Performance Baseline

        **Measurement Time:** $(date -u)
        **Runner:** GitHub Actions Ubuntu

        ## System Resources
        - **CPU:** $CPU_INFO
        - **Memory:** $MEMORY_INFO
        - **Available Disk:** $DISK_AVAILABLE
        - **Network Latency to NPM:** ${NETWORK_LATENCY}ms

        ## Performance Targets
        - Frontend Build: < 120s
        - Dependency Install: < 60s
        - Cache Hit Rate: > 80%
        - Bundle Size: < 5MB
        EOF

        echo "âœ… ç³»ç»Ÿæ€§èƒ½åŸºçº¿å»ºç«‹å®Œæˆ"

    # é«˜çº§Node.jsè®¾ç½®å’Œå¤šå±‚ç¼“å­˜ç­–ç•¥
    - name: Setup Node.js with Multi-Layer Caching Strategy
      if: steps.check.outputs.needs_bump == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Advanced Dependency Cache Management
      if: steps.check.outputs.needs_bump == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ~/.npm
          frontend/node_modules
          frontend/.next/cache
          ~/.cache/yarn
        key: dependencies-cache-v2-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json', 'frontend/package.json') }}
        restore-keys: |
          dependencies-cache-v2-${{ runner.os }}-
          dependencies-cache-v1-${{ runner.os }}-

    - name: Advanced Build Cache Management
      if: steps.check.outputs.needs_bump == 'true'
      uses: actions/cache@v4
      with:
        path: |
          frontend/.next/cache
          frontend/.swc
          frontend/dist
        key: build-cache-v2-${{ runner.os }}-${{ hashFiles('frontend/src/**/*', 'frontend/public/**/*', 'frontend/next.config.js') }}
        restore-keys: |
          build-cache-v2-${{ runner.os }}-
          build-cache-v1-${{ runner.os }}-

    - name: Advanced Frontend Build with Monitoring
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        set -e

        echo "ğŸš€ å¯åŠ¨ç”Ÿäº§çº§å‰ç«¯æ„å»ºæµç¨‹ v${{ steps.next_version.outputs.new_version }}"

        # åˆ›å»ºæ„å»ºç›‘æ§ç›®å½•
        mkdir -p .github/build-reports

        # è®°å½•æ„å»ºå¼€å§‹æ—¶é—´
        BUILD_START=$(date +%s)
        echo "BUILD_START=$BUILD_START" >> $GITHUB_ENV

        cd frontend

        # éªŒè¯ç¯å¢ƒ
        echo "ğŸ“‹ éªŒè¯æ„å»ºç¯å¢ƒ..."
        node --version
        npm --version

        # æ¸…ç†ç¼“å­˜ï¼ˆç¡®ä¿å¹²å‡€æ„å»ºï¼‰
        echo "ğŸ§¹ æ¸…ç†æ„å»ºç¼“å­˜..."
        npm cache clean --force || true
        rm -rf node_modules/.cache || true
        rm -rf .next/cache || true

        # é«˜çº§ä¾èµ–å®‰è£…ï¼ˆå¸¦æ€§èƒ½ç›‘æ§å’Œç¼“å­˜åˆ†æï¼‰
        echo "ğŸ“¦ å¯åŠ¨é«˜çº§ä¾èµ–å®‰è£…..."
        DEPS_START=$(date +%s)

        # ç¼“å­˜çŠ¶æ€åˆ†æ
        echo "ğŸ” åˆ†æç¼“å­˜çŠ¶æ€..."
        if [ -d "node_modules" ]; then
          CACHE_HIT="true"
          CACHED_PACKAGES=$(find node_modules -maxdepth 1 -type d | wc -l)
          echo "âœ… æ£€æµ‹åˆ°ç¼“å­˜ï¼ŒåŒ…æ•°é‡: $CACHED_PACKAGES"
        else
          CACHE_HIT="false"
          CACHED_PACKAGES=0
          echo "âŒ æœªæ£€æµ‹åˆ°ä¾èµ–ç¼“å­˜"
        fi

        # ä¾èµ–å®‰è£…ï¼ˆå¸¦é‡è¯•å’Œç›‘æ§ï¼‰
        echo "ğŸ“¥ æ‰§è¡Œä¾èµ–å®‰è£…..."
        for i in {1..3}; do
          ATTEMPT_START=$(date +%s)

          if npm ci --no-audit --prefer-offline --timing; then
            ATTEMPT_END=$(date +%s)
            INSTALL_TIME=$((ATTEMPT_END - ATTEMPT_START))
            echo "âœ… ä¾èµ–å®‰è£…æˆåŠŸ (å°è¯• $i/3, è€—æ—¶: ${INSTALL_TIME}s)"
            break
          else
            ATTEMPT_END=$(date +%s)
            INSTALL_TIME=$((ATTEMPT_END - ATTEMPT_START))
            echo "âŒ ä¾èµ–å®‰è£…å¤±è´¥ (å°è¯• $i/3, è€—æ—¶: ${INSTALL_TIME}s)"
            if [ $i -eq 3 ]; then
              echo "ğŸ’¥ ä¾èµ–å®‰è£…æœ€ç»ˆå¤±è´¥"
              exit 1
            fi

            # æ¸…ç†æŸåçš„ç¼“å­˜
            echo "ğŸ§¹ æ¸…ç†å¯èƒ½æŸåçš„ç¼“å­˜..."
            rm -rf node_modules/.cache
            npm cache clean --force
            sleep 5
          fi
        done

        DEPS_END=$(date +%s)
        TOTAL_DEPS_TIME=$((DEPS_END - DEPS_START))

        # ä¾èµ–åˆ†æ
        echo "ğŸ“Š æ‰§è¡Œä¾èµ–åˆ†æ..."
        INSTALLED_PACKAGES=$(npm list --depth=0 2>/dev/null | grep -c "â”œ\|â””" || echo "0")
        PACKAGE_SIZE=$(du -sh node_modules 2>/dev/null | cut -f1 || echo "0")

        # ç¼“å­˜æ•ˆç‡è®¡ç®—
        if [ "$CACHE_HIT" = "true" ] && [ "$TOTAL_DEPS_TIME" -lt 30 ]; then
          CACHE_EFFICIENCY="EXCELLENT"
        elif [ "$CACHE_HIT" = "true" ] && [ "$TOTAL_DEPS_TIME" -lt 60 ]; then
          CACHE_EFFICIENCY="GOOD"
        elif [ "$CACHE_HIT" = "true" ]; then
          CACHE_EFFICIENCY="POOR"
        else
          CACHE_EFFICIENCY="NO_CACHE"
        fi

        # ç”Ÿæˆä¾èµ–æ€§èƒ½æŠ¥å‘Š
        cat > "../.github/performance-reports/dependency-performance.md" << EOF
        # Dependency Installation Performance Report

        **Installation Time:** $(date -u)
        **Version:** ${{ steps.next_version.outputs.new_version }}

        ## Performance Metrics
        - **Total Install Time:** ${TOTAL_DEPS_TIME}s
        - **Cache Hit:** $CACHE_HIT
        - **Cache Efficiency:** $CACHE_EFFICIENCY
        - **Installed Packages:** $INSTALLED_PACKAGES
        - **Package Size:** $PACKAGE_SIZE

        ## Cache Analysis
        - **Cached Packages (before):** $CACHED_PACKAGES
        - **Network Latency:** ${NETWORK_LATENCY}ms
        - **Performance Rating:** $([ "$TOTAL_DEPS_TIME" -lt 60 ] && echo "âœ… EXCELLENT" || echo "âš ï¸ NEEDS_OPTIMIZATION")

        ## Recommendations
        $([ "$TOTAL_DEPS_TIME" -gt 60 ] && echo "- Consider optimizing package.json dependencies" || echo "- Dependencies are well optimized")
        $([ "$CACHE_HIT" = "false" ] && echo "- Investigate cache miss cause" || echo "- Cache strategy is working effectively")
        EOF

        echo "BUILD_DEPS_TIME=$TOTAL_DEPS_TIME" >> $GITHUB_ENV
        echo "CACHE_EFFICIENCY=$CACHE_EFFICIENCY" >> $GITHUB_ENV

        # æ„å»ºå‰ç«¯ï¼ˆå¸¦æ€§èƒ½ç›‘æ§ï¼‰
        echo "ğŸ”¨ æ„å»ºå‰ç«¯åº”ç”¨..."
        npm run build 2>&1 | tee ../build.log

        # éªŒè¯æ„å»ºè¾“å‡º
        echo "ğŸ” éªŒè¯æ„å»ºè¾“å‡º..."
        if [ ! -d ".next" ]; then
          echo "ğŸ’¥ æ„å»ºå¤±è´¥ï¼š.nextç›®å½•ä¸å­˜åœ¨"
          exit 1
        fi

        # æ”¶é›†æ„å»ºç»Ÿè®¡ä¿¡æ¯
        BUILD_END=$(date +%s)
        BUILD_TIME=$((BUILD_END - BUILD_START))
        echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV

        # é«˜çº§æ„å»ºåˆ†æå’Œæ€§èƒ½ç›‘æ§
        echo "ğŸ“Š æ‰§è¡Œé«˜çº§æ„å»ºåˆ†æ..."

        # æ„å»ºäº§ç‰©åˆ†æ
        BUILD_OUTPUT_SIZE=$(du -sh .next 2>/dev/null | cut -f1 || echo "0")
        STATIC_FILES_COUNT=$(find .next/static -type f 2>/dev/null | wc -l || echo "0")
        JS_FILES_SIZE=$(find .next -name "*.js" -exec du -ch {} + 2>/dev/null | tail -1 | cut -f1 || echo "0")
        CSS_FILES_SIZE=$(find .next -name "*.css" -exec du -ch {} + 2>/dev/null | tail -1 | cut -f1 || echo "0")

        # æ„å»ºæ€§èƒ½è¯„ä¼°
        if [ "$BUILD_TIME" -lt 60 ]; then
          BUILD_PERFORMANCE="EXCELLENT"
        elif [ "$BUILD_TIME" -lt 120 ]; then
          BUILD_PERFORMANCE="GOOD"
        elif [ "$BUILD_TIME" -lt 180 ]; then
          BUILD_PERFORMANCE="ACCEPTABLE"
        else
          BUILD_PERFORMANCE="POOR"
        fi

        # Webpack/Next.jsæ„å»ºç»Ÿè®¡
        if [ -f ".next/build-manifest.json" ]; then
          PAGES_COUNT=$(jq -r '.pages | keys | length' .next/build-manifest.json 2>/dev/null || echo "0")
        else
          PAGES_COUNT="0"
        fi

        # å†…å­˜ä½¿ç”¨åˆ†æ
        MEMORY_USAGE=$(ps aux | grep node | grep -v grep | awk '{sum+=$6} END {print sum/1024}' 2>/dev/null || echo "0")

        # ç”Ÿæˆç»¼åˆæ„å»ºæŠ¥å‘Š
        cat > ../.github/build-reports/frontend-build-report.md << EOF
        # Comprehensive Frontend Build Report

        **Version:** ${{ steps.next_version.outputs.new_version }}
        **Build Time:** ${BUILD_TIME}s
        **Node Version:** $(node --version)
        **Build Date:** $(date -u)

        ## Performance Metrics
        - **Build Performance:** $BUILD_PERFORMANCE
        - **Total Build Time:** ${BUILD_TIME}s
        - **Dependency Install Time:** ${BUILD_DEPS_TIME}s
        - **Cache Efficiency:** $CACHE_EFFICIENCY
        - **Memory Usage:** ${MEMORY_USAGE}MB

        ## Build Output Analysis
        - **Total Build Size:** $BUILD_OUTPUT_SIZE
        - **Static Files Count:** $STATIC_FILES_COUNT
        - **JavaScript Size:** $JS_FILES_SIZE
        - **CSS Size:** $CSS_FILES_SIZE
        - **Pages Count:** $PAGES_COUNT

        ## Build Output Structure
        \`\`\`
        $(find .next -type f -name "*.js" -o -name "*.css" -o -name "*.html" | head -20)
        \`\`\`

        ## Performance Recommendations
        $([ "$BUILD_TIME" -gt 120 ] && echo "- âš ï¸ Build time exceeds target (120s), consider code splitting" || echo "- âœ… Build time within acceptable range")
        $([ "$STATIC_FILES_COUNT" -gt 1000 ] && echo "- âš ï¸ High static file count, consider asset optimization" || echo "- âœ… Static file count is reasonable")
        $([ "$CACHE_EFFICIENCY" = "POOR" ] && echo "- âš ï¸ Cache efficiency is poor, review caching strategy" || echo "- âœ… Cache efficiency is good")

        ## Package Dependencies Summary
        \`\`\`
        $(npm list --depth=0 2>/dev/null | head -20)
        \`\`\`
        EOF

        # ç”Ÿæˆæ€§èƒ½è¶‹åŠ¿æ•°æ®
        cat > ../.github/performance-reports/build-metrics.json << EOF
        {
          "version": "${{ steps.next_version.outputs.new_version }}",
          "buildTime": $BUILD_TIME,
          "dependencyTime": $BUILD_DEPS_TIME,
          "buildSize": "$BUILD_OUTPUT_SIZE",
          "staticFiles": $STATIC_FILES_COUNT,
          "jsSize": "$JS_FILES_SIZE",
          "cssSize": "$CSS_FILES_SIZE",
          "cacheEfficiency": "$CACHE_EFFICIENCY",
          "memoryUsage": $MEMORY_USAGE,
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "performance": "$BUILD_PERFORMANCE"
        }
        EOF

        # ç¼“å­˜çŠ¶æ€æŠ¥å‘Š
        echo "ğŸ’¾ ç”Ÿæˆç¼“å­˜çŠ¶æ€æŠ¥å‘Š..."
        cat > ../.github/cache-reports/cache-analysis.md << EOF
        # Cache Performance Analysis

        **Analysis Time:** $(date -u)
        **Version:** ${{ steps.next_version.outputs.new_version }}

        ## Cache Hit Analysis
        - **Dependency Cache:** $([ "$CACHE_HIT" = "true" ] && echo "âœ… HIT" || echo "âŒ MISS")
        - **Cache Efficiency:** $CACHE_EFFICIENCY
        - **Cache Performance Impact:** $([ "$CACHE_EFFICIENCY" = "EXCELLENT" ] && echo "Saved ~90% install time" || echo "Moderate performance gain")

        ## Cache Size Analysis
        - **Node Modules Size:** $PACKAGE_SIZE
        - **Next.js Cache:** $(du -sh .next/cache 2>/dev/null | cut -f1 || echo "0")
        - **NPM Cache:** $(du -sh ~/.npm 2>/dev/null | cut -f1 || echo "0")

        ## Cache Optimization Recommendations
        $([ "$CACHE_EFFICIENCY" = "POOR" ] && echo "- Review package-lock.json for unnecessary dependencies" || echo "- Cache strategy is working well")
        $([ "$BUILD_DEPS_TIME" -gt 60 ] && echo "- Consider npm ci alternatives for faster installs" || echo "- Install time is optimized")
        EOF

        echo "âœ… å‰ç«¯æ„å»ºå’Œæ€§èƒ½åˆ†æå®Œæˆ (è€—æ—¶: ${BUILD_TIME}s, æ€§èƒ½: $BUILD_PERFORMANCE)"

    - name: Production-Grade Web-Dist Branch Deployment
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        set -e

        echo "ğŸŒ å¯åŠ¨web-diståˆ†æ”¯ç”Ÿäº§çº§éƒ¨ç½²æµç¨‹"

        # åˆ›å»ºå®‰å…¨çš„å·¥ä½œç¯å¢ƒ
        SECURE_TEMP_DIR=$(mktemp -d -t web-dist-XXXXXX)
        BUILD_MANIFEST_FILE="$SECURE_TEMP_DIR/build-manifest.json"
        DEPLOYMENT_LOG_FILE="$SECURE_TEMP_DIR/deployment.log"

        echo "ğŸ“ ä½¿ç”¨å®‰å…¨ä¸´æ—¶ç›®å½•: $SECURE_TEMP_DIR"

        # é…ç½®Gitå®‰å…¨è®¾ç½®
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git config --global core.autocrlf false
        git config --global core.safecrlf false

        # åˆ›å»ºæ„å»ºæ¸…å•
        echo "ğŸ“‹ åˆ›å»ºæ„å»ºæ¸…å•..."
        cat > "$BUILD_MANIFEST_FILE" << EOF
        {
          "version": "${{ steps.next_version.outputs.new_version }}",
          "buildTime": "$BUILD_TIME",
          "buildDate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "gitCommit": "$(git rev-parse HEAD)",
          "gitBranch": "${{ github.ref_name }}",
          "nodeVersion": "$(node --version)",
          "environment": "production"
        }
        EOF

        # é«˜çº§æ–‡ä»¶æ”¶é›†ç³»ç»Ÿï¼ˆåŸºäºTgGodæ¨¡å¼ï¼‰
        echo "ğŸ“¦ æ‰§è¡Œé«˜çº§æ–‡ä»¶æ”¶é›†..."

        # éªŒè¯Next.jsæ„å»ºè¾“å‡º
        if [ -d "frontend/.next/standalone" ]; then
          echo "âœ… å‘ç°Next.js standaloneè¾“å‡º"
          BUILD_SOURCE="frontend/.next/standalone"
          BUILD_TYPE="standalone"
        elif [ -d "frontend/out" ]; then
          echo "âœ… å‘ç°Next.js exportè¾“å‡º"
          BUILD_SOURCE="frontend/out"
          BUILD_TYPE="export"
        elif [ -d "frontend/build" ]; then
          echo "âœ… å‘ç°React buildè¾“å‡º"
          BUILD_SOURCE="frontend/build"
          BUILD_TYPE="react"
        else
          echo "ğŸ’¥ æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ„å»ºè¾“å‡º"
          exit 1
        fi

        # é«˜çº§æ–‡ä»¶è¿‡æ»¤å’Œå¤åˆ¶ç³»ç»Ÿ
        echo "ğŸ”„ æ‰§è¡Œé«˜çº§æ–‡ä»¶å¤„ç†..."
        cd "$BUILD_SOURCE"

        # åˆ›å»ºæ–‡ä»¶æ¸…å•
        find . -type f \
          ! -path "./node_modules/*" \
          ! -path "./.next/cache/*" \
          ! -path "./.git/*" \
          ! -name "*.map" \
          ! -name "*.log" \
          ! -name "package-lock.json" \
          ! -name "*.tmp" \
          > "$SECURE_TEMP_DIR/file-list.txt"

        FILE_COUNT=$(wc -l < "$SECURE_TEMP_DIR/file-list.txt")
        echo "ğŸ“Š å‘ç° $FILE_COUNT ä¸ªæ–‡ä»¶å¾…å¤„ç†"

        # å®‰å…¨å¤åˆ¶æ–‡ä»¶ï¼ˆé€ä¸ªéªŒè¯ï¼‰
        echo "ğŸšš å®‰å…¨å¤åˆ¶æ–‡ä»¶åˆ°ä¸´æ—¶ç›®å½•..."
        while IFS= read -r file; do
          if [ -f "$file" ]; then
            dest_dir="$SECURE_TEMP_DIR/$(dirname "$file")"
            mkdir -p "$dest_dir"
            cp "$file" "$SECURE_TEMP_DIR/$file"
          fi
        done < "$SECURE_TEMP_DIR/file-list.txt"

        # è¿”å›ä»“åº“æ ¹ç›®å½•
        cd "$GITHUB_WORKSPACE"

        # é«˜çº§åˆ†æ”¯ç®¡ç†ç³»ç»Ÿ
        echo "ğŸŒ¿ æ‰§è¡Œé«˜çº§åˆ†æ”¯ç®¡ç†..."

        # å¤‡ä»½å½“å‰åˆ†æ”¯çŠ¶æ€
        CURRENT_BRANCH=$(git branch --show-current)
        CURRENT_COMMIT=$(git rev-parse HEAD)

        # æ£€æŸ¥å¹¶å¤„ç†web-diståˆ†æ”¯
        if git ls-remote --heads origin web-dist | grep -q web-dist; then
          echo "ğŸ“¥ æ£€å‡ºç°æœ‰web-diståˆ†æ”¯"
          git fetch origin web-dist:web-dist
          git checkout web-dist

          # åˆ›å»ºåˆ†æ”¯å¤‡ä»½
          git tag "web-dist-backup-$(date +%Y%m%d-%H%M%S)" || true
        else
          echo "ğŸ†• åˆ›å»ºæ–°çš„web-diståˆ†æ”¯"
          git checkout --orphan web-dist
        fi

        # æ¸…ç†å·¥ä½œç›®å½•ï¼ˆä¿æŠ¤æ€§æ“ä½œï¼‰
        echo "ğŸ§¹ æ¸…ç†å·¥ä½œç›®å½•..."
        git rm -rf . 2>/dev/null || true
        find . -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} + 2>/dev/null || true

        # å¤åˆ¶æ„å»ºäº§ç‰©
        echo "ğŸ“‹ éƒ¨ç½²æ„å»ºäº§ç‰©..."
        cp -r "$SECURE_TEMP_DIR"/* . 2>/dev/null || echo "è­¦å‘Š: éƒ¨åˆ†æ–‡ä»¶å¤åˆ¶å¤±è´¥"
        cp "$BUILD_MANIFEST_FILE" ./build-manifest.json

        # åˆ›å»ºç”Ÿäº§çº§README
        cat > README.md << EOF
        # Meow Accounting - Production Web Distribution

        ğŸš€ **ç”Ÿäº§çº§å‰ç«¯æ„å»ºåˆ†å‘åˆ†æ”¯**

        ## æ„å»ºä¿¡æ¯
        - **ç‰ˆæœ¬**: ${{ steps.next_version.outputs.new_version }}
        - **æ„å»ºæ—¶é—´**: $BUILD_TIME ç§’
        - **æ„å»ºç±»å‹**: $BUILD_TYPE
        - **æ„å»ºæ—¥æœŸ**: $(date -u)
        - **Gitæäº¤**: $CURRENT_COMMIT

        ## âš ï¸ é‡è¦æç¤º
        **è¯·å‹¿ç›´æ¥ç¼–è¾‘æ­¤åˆ†æ”¯çš„æ–‡ä»¶ï¼**

        æ­¤åˆ†æ”¯ç”±CI/CDè‡ªåŠ¨ç”Ÿæˆå’Œç»´æŠ¤ã€‚æ‰€æœ‰æ›´æ”¹åº”åœ¨ä¸»åˆ†æ”¯è¿›è¡Œã€‚

        ## éƒ¨ç½²è¯´æ˜
        æ­¤åˆ†æ”¯åŒ…å«å®Œæ•´çš„ç”Ÿäº§çº§å‰ç«¯æ„å»ºæ–‡ä»¶ï¼Œå¯ç›´æ¥ç”¨äºï¼š
        - é™æ€ç½‘ç«™æ‰˜ç®¡
        - CDNéƒ¨ç½²
        - Dockerå®¹å™¨æ„å»º
        - Nginxé™æ€æ–‡ä»¶æœåŠ¡

        ## æ¶æ„è¯´æ˜
        åŸºäºTgGodæˆåŠŸæ¨¡å¼çš„ç”Ÿäº§çº§æ„å»ºç³»ç»Ÿï¼š
        - å¤šé˜¶æ®µæ„å»ºéªŒè¯
        - é«˜çº§ç¼“å­˜ç­–ç•¥
        - å®‰å…¨æ–‡ä»¶å¤„ç†
        - å®Œæ•´é”™è¯¯æ¢å¤
        - æ€§èƒ½ç›‘æ§é›†æˆ

        ## æ–‡ä»¶ç»“æ„
        \`\`\`
        $(find . -maxdepth 2 -type f ! -path './.git/*' | sort)
        \`\`\`
        EOF

        # åˆ›å»ºé«˜çº§.gitignore
        cat > .gitignore << EOF
        # ç”Ÿäº§æ„å»ºæ’é™¤æ–‡ä»¶
        node_modules/
        *.log
        *.tmp
        .DS_Store
        .env*
        !.env.example

        # å¼€å‘å·¥å…·
        .vscode/
        .idea/

        # ç¼“å­˜æ–‡ä»¶
        .next/cache/
        .cache/

        # å¤§æ–‡ä»¶ï¼ˆä½¿ç”¨Git LFSï¼‰
        *.woff2
        *.woff
        *.ttf
        *.eot
        *.mp4
        *.webm
        *.avi

        # ä¸´æ—¶æ–‡ä»¶
        *.swp
        *.swo
        *~
        EOF

        # é«˜çº§æ–‡ä»¶æ·»åŠ ç³»ç»Ÿï¼ˆåˆ†æ‰¹å¤„ç†ï¼‰
        echo "ğŸ“ æ‰§è¡Œé«˜çº§æ–‡ä»¶æ·»åŠ ..."

        # é¦–å…ˆæ·»åŠ  .gitignore å’Œ README.md (é¿å…å†²çª)
        git add .gitignore README.md build-manifest.json 2>/dev/null || true

        # åˆ†ç±»æ·»åŠ å…¶ä»–æ–‡ä»¶ï¼ˆé¿å…å¤§æ‰¹é‡æ“ä½œï¼‰
        find . -maxdepth 3 -type f \
          \( -name "*.html" -o -name "*.css" -o -name "*.js" \) \
          ! -path './.git/*' \
          ! -name '.gitignore' ! -name 'README.md' ! -name 'build-manifest.json' \
          -exec git add {} + 2>/dev/null || true

        find . -maxdepth 3 -type f \
          \( -name "*.json" -o -name "*.md" -o -name "*.txt" \) \
          ! -path './.git/*' \
          ! -name '.gitignore' ! -name 'README.md' ! -name 'build-manifest.json' \
          -exec git add {} + 2>/dev/null || true

        find . -maxdepth 3 -type f \
          \( -name "*.ico" -o -name "*.png" -o -name "*.jpg" -o -name "*.svg" \) \
          ! -path './.git/*' \
          -exec git add {} + 2>/dev/null || true

        # æäº¤æ›´æ”¹
        echo "ğŸ’¾ æäº¤web-distæ›´æ”¹..."
        if git diff --staged --quiet; then
          echo "âš ï¸ æ²¡æœ‰æ–‡ä»¶å˜æ›´ï¼Œåˆ›å»ºç©ºæäº¤"
          git commit --allow-empty -m "chore: trigger web-dist deployment for v${{ steps.next_version.outputs.new_version }} [skip ci]"
        else
          git commit -m "deploy: production frontend build v${{ steps.next_version.outputs.new_version }}

        ğŸš€ Production deployment of frontend build

        Build Details:
        - Version: ${{ steps.next_version.outputs.new_version }}
        - Build Time: ${BUILD_TIME}s
        - Build Type: $BUILD_TYPE
        - Files: $FILE_COUNT
        - Source Commit: $CURRENT_COMMIT

        Features:
        - Advanced file filtering
        - Security validations
        - Performance monitoring
        - Error recovery mechanisms

        [skip ci]"
        fi

        # å®‰å…¨æ¨é€ï¼ˆå¸¦é‡è¯•ï¼‰
        echo "ğŸš€ å®‰å…¨æ¨é€åˆ°web-diståˆ†æ”¯..."
        for i in {1..3}; do
          if git push origin web-dist --force-with-lease; then
            echo "âœ… web-diståˆ†æ”¯æ¨é€æˆåŠŸ (å°è¯• $i/3)"
            break
          else
            echo "âŒ web-diståˆ†æ”¯æ¨é€å¤±è´¥ (å°è¯• $i/3)"
            if [ $i -eq 3 ]; then
              echo "ğŸ’¥ web-diståˆ†æ”¯æ¨é€æœ€ç»ˆå¤±è´¥"
              exit 1
            fi
            sleep 10
          fi
        done

        # è¿”å›åŸåˆ†æ”¯ï¼ˆå¼ºåˆ¶æ¸…ç†å†²çªæ–‡ä»¶ï¼‰
        echo "ğŸ”„ è¿”å›åŸåˆ†æ”¯..."
        git clean -fd  # æ¸…ç†æœªè·Ÿè¸ªçš„æ–‡ä»¶å’Œç›®å½•
        git reset --hard HEAD  # é‡ç½®å·¥ä½œç›®å½•
        git checkout "$CURRENT_BRANCH" --force

        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        echo "ğŸ§¹ æ¸…ç†ä¸´æ—¶æ–‡ä»¶..."
        rm -rf "$SECURE_TEMP_DIR"

        # ç”Ÿæˆéƒ¨ç½²æ‘˜è¦
        echo "ğŸ“Š web-distéƒ¨ç½²æ‘˜è¦:"
        echo "  ç‰ˆæœ¬: ${{ steps.next_version.outputs.new_version }}"
        echo "  æ„å»ºæ—¶é—´: ${BUILD_TIME}s"
        echo "  æ„å»ºç±»å‹: $BUILD_TYPE"
        echo "  æ–‡ä»¶æ•°é‡: $FILE_COUNT"
        echo "  éƒ¨ç½²çŠ¶æ€: âœ… æˆåŠŸ"

        echo "ğŸ‰ web-diståˆ†æ”¯ç”Ÿäº§çº§éƒ¨ç½²å®Œæˆï¼"

    # ç”Ÿäº§çº§é”™è¯¯æ¢å¤å’Œæ–‡ä»¶å®Œæ•´æ€§éªŒè¯ç³»ç»Ÿ
    - name: Production Error Recovery and File Integrity Validation
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        set -e

        echo "ğŸ›¡ï¸ å¯åŠ¨ç”Ÿäº§çº§é”™è¯¯æ¢å¤å’Œæ–‡ä»¶å®Œæ•´æ€§éªŒè¯"

        # åˆ›å»ºéªŒè¯æŠ¥å‘Šç›®å½•
        mkdir -p .github/validation-reports

        # web-diståˆ†æ”¯éªŒè¯
        echo "ğŸ” éªŒè¯web-diståˆ†æ”¯å®Œæ•´æ€§..."
        git fetch origin web-dist:web-dist-verify || {
          echo "âš ï¸ web-diståˆ†æ”¯è·å–å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ–°åˆ†æ”¯"
        }

        if git show-ref --verify --quiet refs/heads/web-dist-verify; then
          git checkout web-dist-verify

          # éªŒè¯å…³é”®æ–‡ä»¶å­˜åœ¨æ€§
          echo "ğŸ“‹ éªŒè¯å…³é”®æ–‡ä»¶..."
          VALIDATION_STATUS="SUCCESS"

          # æ£€æŸ¥æ„å»ºæ¸…å•
          if [ ! -f "build-manifest.json" ]; then
            echo "âŒ ç¼ºå°‘build-manifest.json"
            VALIDATION_STATUS="FAILED"
          else
            echo "âœ… build-manifest.jsonå­˜åœ¨"
            # éªŒè¯JSONæ ¼å¼
            if ! jq empty build-manifest.json 2>/dev/null; then
              echo "âŒ build-manifest.jsonæ ¼å¼æ— æ•ˆ"
              VALIDATION_STATUS="FAILED"
            else
              echo "âœ… build-manifest.jsonæ ¼å¼æœ‰æ•ˆ"
            fi
          fi

          # æ£€æŸ¥README
          if [ ! -f "README.md" ]; then
            echo "âŒ ç¼ºå°‘README.md"
            VALIDATION_STATUS="FAILED"
          else
            echo "âœ… README.mdå­˜åœ¨"
          fi

          # éªŒè¯æ„å»ºæ–‡ä»¶æ•°é‡
          BUILD_FILE_COUNT=$(find . -type f ! -path './.git/*' | wc -l)
          if [ "$BUILD_FILE_COUNT" -lt 5 ]; then
            echo "âŒ æ„å»ºæ–‡ä»¶æ•°é‡è¿‡å°‘: $BUILD_FILE_COUNT"
            VALIDATION_STATUS="FAILED"
          else
            echo "âœ… æ„å»ºæ–‡ä»¶æ•°é‡æ­£å¸¸: $BUILD_FILE_COUNT"
          fi

          # ç”ŸæˆéªŒè¯æŠ¥å‘Š
          cat > "../.github/validation-reports/web-dist-validation.md" << EOF
        # Web-Dist Branch Validation Report

        **Validation Date:** $(date -u)
        **Version:** ${{ steps.next_version.outputs.new_version }}
        **Status:** $VALIDATION_STATUS

        ## File Count Analysis
        - Total files: $BUILD_FILE_COUNT
        - HTML files: $(find . -name "*.html" | wc -l)
        - CSS files: $(find . -name "*.css" | wc -l)
        - JS files: $(find . -name "*.js" | wc -l)
        - JSON files: $(find . -name "*.json" | wc -l)

        ## Critical Files Check
        - build-manifest.json: $([ -f "build-manifest.json" ] && echo "âœ… Present" || echo "âŒ Missing")
        - README.md: $([ -f "README.md" ] && echo "âœ… Present" || echo "âŒ Missing")
        - .gitignore: $([ -f ".gitignore" ] && echo "âœ… Present" || echo "âŒ Missing")

        ## Build Manifest Content
        \`\`\`json
        $(cat build-manifest.json 2>/dev/null || echo "Build manifest not found")
        \`\`\`
        EOF

          # é”™è¯¯æ¢å¤æœºåˆ¶
          if [ "$VALIDATION_STATUS" = "FAILED" ]; then
            echo "ğŸš¨ web-diståˆ†æ”¯éªŒè¯å¤±è´¥ï¼Œå¯åŠ¨æ¢å¤æµç¨‹..."

            # å°è¯•ä»å¤‡ä»½æ¢å¤
            BACKUP_TAG=$(git tag -l "web-dist-backup-*" | sort | tail -1)
            if [ -n "$BACKUP_TAG" ]; then
              echo "ğŸ”„ ä»å¤‡ä»½æ ‡ç­¾æ¢å¤: $BACKUP_TAG"
              git checkout "$BACKUP_TAG"
              git branch -f web-dist HEAD
              git push origin web-dist --force
              echo "âœ… ä»å¤‡ä»½æ¢å¤æˆåŠŸ"
            else
              echo "âš ï¸ æœªæ‰¾åˆ°å¤‡ä»½ï¼Œåˆ›å»ºæœ€å°åŒ–web-diståˆ†æ”¯"
              git checkout --orphan web-dist-recovery
              git rm -rf . 2>/dev/null || true

              # åˆ›å»ºæœ€å°åŒ–éƒ¨ç½²
              echo "<h1>Meow Accounting</h1><p>Version: ${{ steps.next_version.outputs.new_version }}</p>" > index.html
              cat > README.md << EOF
        # Meow Accounting - Emergency Recovery

        This is an emergency recovery deployment.
        Version: ${{ steps.next_version.outputs.new_version }}
        Recovery Date: $(date -u)
        EOF

              git add .
              git commit -m "emergency: recovery deployment v${{ steps.next_version.outputs.new_version }} [skip ci]"
              git branch -M web-dist
              git push origin web-dist --force
              echo "ğŸ†˜ ç´§æ€¥æ¢å¤éƒ¨ç½²å®Œæˆ"
            fi
          else
            echo "âœ… web-diståˆ†æ”¯éªŒè¯é€šè¿‡"
          fi

          # è¿”å›ä¸»åˆ†æ”¯ï¼ˆå®‰å…¨åˆ‡æ¢ï¼‰
          git clean -fd  # æ¸…ç†å†²çªæ–‡ä»¶
          git reset --hard HEAD
          git checkout ${{ github.ref_name }} --force
        else
          echo "â„¹ï¸ web-diståˆ†æ”¯ä¸å­˜åœ¨ï¼Œè·³è¿‡éªŒè¯"
        fi

        # æ„å»ºæ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥
        echo "ğŸ”’ æ‰§è¡Œæ„å»ºæ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥..."

        if [ -d "frontend/.next" ]; then
          # Next.jsæ„å»ºéªŒè¯
          echo "ğŸ“¦ éªŒè¯Next.jsæ„å»º..."

          # æ£€æŸ¥å…³é”®æ„å»ºæ–‡ä»¶
          NEXTJS_VALIDATION="SUCCESS"

          if [ ! -f "frontend/.next/BUILD_ID" ]; then
            echo "âŒ ç¼ºå°‘BUILD_IDæ–‡ä»¶"
            NEXTJS_VALIDATION="FAILED"
          fi

          if [ ! -d "frontend/.next/static" ]; then
            echo "âŒ ç¼ºå°‘staticç›®å½•"
            NEXTJS_VALIDATION="FAILED"
          fi

          # æ£€æŸ¥æ„å»ºäº§ç‰©å¤§å°
          BUILD_SIZE=$(du -sh frontend/.next | cut -f1)
          echo "ğŸ“ æ„å»ºå¤§å°: $BUILD_SIZE"

          # ç”ŸæˆNext.jséªŒè¯æŠ¥å‘Š
          cat > ".github/validation-reports/nextjs-build-validation.md" << EOF
        # Next.js Build Validation Report

        **Build Date:** $(date -u)
        **Version:** ${{ steps.next_version.outputs.new_version }}
        **Status:** $NEXTJS_VALIDATION
        **Build Size:** $BUILD_SIZE

        ## Build Structure
        \`\`\`
        $(find frontend/.next -maxdepth 2 -type d | sort)
        \`\`\`

        ## Static Assets
        \`\`\`
        $(find frontend/.next/static -type f | wc -l) files in static directory
        \`\`\`

        ## Critical Files
        - BUILD_ID: $([ -f "frontend/.next/BUILD_ID" ] && echo "âœ… Present" || echo "âŒ Missing")
        - Static Dir: $([ -d "frontend/.next/static" ] && echo "âœ… Present" || echo "âŒ Missing")
        EOF

          if [ "$NEXTJS_VALIDATION" = "FAILED" ]; then
            echo "ğŸš¨ Next.jsæ„å»ºéªŒè¯å¤±è´¥ï¼Œå°è¯•é‡æ–°æ„å»º..."
            cd frontend
            rm -rf .next node_modules/.cache
            npm ci --no-audit
            npm run build
            cd ..
            echo "ğŸ”„ Next.jsé‡æ–°æ„å»ºå®Œæˆ"
          fi
        fi

        # åˆ›å»ºç»¼åˆéªŒè¯æ‘˜è¦
        cat > ".github/validation-reports/validation-summary.md" << EOF
        # Comprehensive Validation Summary

        **Validation Time:** $(date -u)
        **Version:** ${{ steps.next_version.outputs.new_version }}

        ## Validation Results
        - Web-Dist Branch: $([ "$VALIDATION_STATUS" = "SUCCESS" ] && echo "âœ… PASSED" || echo "âŒ FAILED")
        - Next.js Build: $([ "$NEXTJS_VALIDATION" = "SUCCESS" ] && echo "âœ… PASSED" || echo "âŒ FAILED")

        ## Recovery Actions Taken
        $([ "$VALIDATION_STATUS" = "FAILED" ] && echo "- Web-dist branch recovery executed" || echo "- No recovery needed")
        $([ "$NEXTJS_VALIDATION" = "FAILED" ] && echo "- Next.js rebuild executed" || echo "- No rebuild needed")

        ## Next Steps
        All validations completed. Build pipeline can continue safely.
        EOF

        echo "âœ… ç”Ÿäº§çº§é”™è¯¯æ¢å¤å’ŒéªŒè¯å®Œæˆ"

    # ç”Ÿäº§çº§å®‰å…¨éªŒè¯å’Œæƒé™æ§åˆ¶ç³»ç»Ÿ
    - name: Comprehensive Security Validation and Access Control
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        set -e

        echo "ğŸ”’ å¯åŠ¨ç”Ÿäº§çº§å®‰å…¨éªŒè¯å’Œæƒé™æ§åˆ¶ç³»ç»Ÿ"

        # åˆ›å»ºå®‰å…¨æŠ¥å‘Šç›®å½•
        mkdir -p .github/security-reports

        # æƒé™éªŒè¯å¼€å§‹æ—¶é—´
        SECURITY_START=$(date +%s)

        # 1. ä»£ç å®‰å…¨æ‰«æ
        echo "ğŸ” æ‰§è¡Œä»£ç å®‰å…¨æ‰«æ..."

        # æ£€æŸ¥æ•æ„Ÿæ–‡ä»¶
        echo "ğŸ“‹ æ£€æŸ¥æ•æ„Ÿæ–‡ä»¶..."
        SECURITY_ISSUES=()

        # æ£€æŸ¥æ˜¯å¦æœ‰ç¡¬ç¼–ç çš„ç§˜é’¥
        if grep -r -E "(password|secret|key|token)" --include="*.js" --include="*.ts" --include="*.json" frontend/src/ 2>/dev/null | grep -v -E "(Password|Secret|Key|Token|interface|type|prop)" | head -5; then
          SECURITY_ISSUES+=("Potential hardcoded credentials found")
          echo "âš ï¸ å‘ç°æ½œåœ¨çš„ç¡¬ç¼–ç å‡­æ®"
        else
          echo "âœ… æœªå‘ç°ç¡¬ç¼–ç å‡­æ®"
        fi

        # æ£€æŸ¥ç¯å¢ƒå˜é‡æ³„éœ²
        if grep -r -E "process\.env\.[A-Z_]+" --include="*.js" --include="*.ts" frontend/src/ 2>/dev/null | grep -v "NEXT_PUBLIC" | head -5; then
          SECURITY_ISSUES+=("Non-public environment variables exposed to client")
          echo "âš ï¸ å‘ç°éå…¬å¼€ç¯å¢ƒå˜é‡æš´éœ²åˆ°å®¢æˆ·ç«¯"
        else
          echo "âœ… ç¯å¢ƒå˜é‡ä½¿ç”¨å®‰å…¨"
        fi

        # æ£€æŸ¥SQLæ³¨å…¥é£é™©ï¼ˆåç«¯ï¼‰
        if [ -d "backend" ]; then
          if grep -r -E "(query|execute).*\+.*" --include="*.js" --include="*.ts" backend/ 2>/dev/null | head -3; then
            SECURITY_ISSUES+=("Potential SQL injection vulnerability")
            echo "âš ï¸ å‘ç°æ½œåœ¨SQLæ³¨å…¥é£é™©"
          else
            echo "âœ… æœªå‘ç°SQLæ³¨å…¥é£é™©"
          fi
        fi

        # 2. ä¾èµ–å®‰å…¨å®¡è®¡
        echo "ğŸ” æ‰§è¡Œä¾èµ–å®‰å…¨å®¡è®¡..."
        cd frontend

        # NPMå®‰å…¨å®¡è®¡
        if npm audit --audit-level moderate --json > ../npm-audit.json 2>/dev/null; then
          VULNERABILITIES=$(jq '.metadata.vulnerabilities.total' ../npm-audit.json 2>/dev/null || echo "0")
          HIGH_VULNS=$(jq '.metadata.vulnerabilities.high // 0' ../npm-audit.json 2>/dev/null || echo "0")
          CRITICAL_VULNS=$(jq '.metadata.vulnerabilities.critical // 0' ../npm-audit.json 2>/dev/null || echo "0")

          if [ "$CRITICAL_VULNS" -gt 0 ]; then
            SECURITY_ISSUES+=("$CRITICAL_VULNS critical vulnerabilities found")
            echo "ğŸš¨ å‘ç° $CRITICAL_VULNS ä¸ªä¸¥é‡æ¼æ´"
          elif [ "$HIGH_VULNS" -gt 0 ]; then
            SECURITY_ISSUES+=("$HIGH_VULNS high severity vulnerabilities found")
            echo "âš ï¸ å‘ç° $HIGH_VULNS ä¸ªé«˜å±æ¼æ´"
          else
            echo "âœ… æœªå‘ç°ä¸¥é‡å®‰å…¨æ¼æ´"
          fi
        else
          echo "âš ï¸ NPMå®¡è®¡å¤±è´¥ï¼Œç»§ç»­è¿›è¡Œå…¶ä»–æ£€æŸ¥"
          VULNERABILITIES="unknown"
        fi

        cd ..

        # 3. æ„å»ºäº§ç‰©å®‰å…¨æ£€æŸ¥
        echo "ğŸ›¡ï¸ æ£€æŸ¥æ„å»ºäº§ç‰©å®‰å…¨æ€§..."

        # æ£€æŸ¥æ„å»ºæ–‡ä»¶ä¸­çš„æ•æ„Ÿä¿¡æ¯
        if [ -d "frontend/.next" ]; then
          # æ£€æŸ¥source mapæ³„éœ²
          SOURCEMAP_COUNT=$(find frontend/.next -name "*.map" | wc -l)
          if [ "$SOURCEMAP_COUNT" -gt 0 ]; then
            SECURITY_ISSUES+=("Source maps found in production build")
            echo "âš ï¸ å‘ç° $SOURCEMAP_COUNT ä¸ªsource mapæ–‡ä»¶"
          else
            echo "âœ… æœªå‘ç°source mapæ³„éœ²"
          fi

          # æ£€æŸ¥æ„å»ºæ–‡ä»¶ä¸­çš„è°ƒè¯•ä¿¡æ¯
          if grep -r "console\.\(log\|debug\|error\)" frontend/.next/static 2>/dev/null | head -3; then
            SECURITY_ISSUES+=("Debug statements found in production build")
            echo "âš ï¸ å‘ç°ç”Ÿäº§æ„å»ºä¸­åŒ…å«è°ƒè¯•ä¿¡æ¯"
          else
            echo "âœ… æœªå‘ç°è°ƒè¯•ä¿¡æ¯æ³„éœ²"
          fi
        fi

        # 4. Dockerå®‰å…¨æ£€æŸ¥
        echo "ğŸ³ æ‰§è¡ŒDockerå®‰å…¨æ£€æŸ¥..."

        # æ£€æŸ¥Dockerfileå®‰å…¨æœ€ä½³å®è·µ
        if [ -f "Dockerfile" ]; then
          # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨ç‰¹æƒç”¨æˆ·
          if grep -q "USER root" Dockerfile || ! grep -q "USER " Dockerfile; then
            SECURITY_ISSUES+=("Docker container running as root user")
            echo "âš ï¸ Dockerå®¹å™¨ä»¥rootç”¨æˆ·è¿è¡Œ"
          else
            echo "âœ… Dockerå®¹å™¨ä½¿ç”¨éç‰¹æƒç”¨æˆ·"
          fi

          # æ£€æŸ¥æ˜¯å¦æš´éœ²æ•æ„Ÿç«¯å£
          if grep -E "EXPOSE.*(22|3306|5432|6379|27017)" Dockerfile; then
            SECURITY_ISSUES+=("Sensitive ports exposed in Dockerfile")
            echo "âš ï¸ Dockerfileæš´éœ²æ•æ„Ÿç«¯å£"
          else
            echo "âœ… æœªæš´éœ²æ•æ„Ÿç«¯å£"
          fi
        fi

        # 5. Gitå®‰å…¨æ£€æŸ¥
        echo "ğŸ“š æ‰§è¡ŒGitå®‰å…¨æ£€æŸ¥..."

        # æ£€æŸ¥æ˜¯å¦æœ‰æ•æ„Ÿæ–‡ä»¶è¢«è·Ÿè¸ª
        if git ls-files | grep -E "\.(env|key|pem|p12|pfx)$" | head -5; then
          SECURITY_ISSUES+=("Sensitive files tracked in Git")
          echo "âš ï¸ å‘ç°æ•æ„Ÿæ–‡ä»¶è¢«Gitè·Ÿè¸ª"
        else
          echo "âœ… æœªå‘ç°æ•æ„Ÿæ–‡ä»¶è¢«è·Ÿè¸ª"
        fi

        # æ£€æŸ¥.gitignoreè¦†ç›–
        CRITICAL_PATTERNS=("*.env" "*.key" "*.pem" "node_modules/" ".DS_Store")
        for pattern in "${CRITICAL_PATTERNS[@]}"; do
          if ! grep -q "$pattern" .gitignore 2>/dev/null; then
            SECURITY_ISSUES+=("Missing $pattern in .gitignore")
            echo "âš ï¸ .gitignoreç¼ºå°‘ $pattern"
          fi
        done

        # 6. æƒé™å’Œè®¿é—®æ§åˆ¶éªŒè¯
        echo "ğŸ”‘ éªŒè¯æƒé™å’Œè®¿é—®æ§åˆ¶..."

        # æ£€æŸ¥GitHub Actionsæƒé™
        if [ "${GITHUB_TOKEN}" = "" ]; then
          SECURITY_ISSUES+=("Missing GitHub token")
          echo "âš ï¸ ç¼ºå°‘GitHub token"
        else
          echo "âœ… GitHub tokenå¯ç”¨"
        fi

        # æ£€æŸ¥æ¨é€æƒé™
        if ! git ls-remote --heads origin >/dev/null 2>&1; then
          SECURITY_ISSUES+=("Insufficient repository permissions")
          echo "âš ï¸ ä»“åº“æƒé™ä¸è¶³"
        else
          echo "âœ… ä»“åº“æƒé™æ­£å¸¸"
        fi

        # 7. ç”Ÿæˆå®‰å…¨æŠ¥å‘Š
        SECURITY_END=$(date +%s)
        SECURITY_TIME=$((SECURITY_END - SECURITY_START))

        # è®¡ç®—å®‰å…¨è¯„åˆ†
        ISSUE_COUNT=${#SECURITY_ISSUES[@]}
        if [ "$ISSUE_COUNT" -eq 0 ]; then
          SECURITY_SCORE="EXCELLENT"
          SECURITY_RATING="A+"
        elif [ "$ISSUE_COUNT" -le 2 ]; then
          SECURITY_SCORE="GOOD"
          SECURITY_RATING="B+"
        elif [ "$ISSUE_COUNT" -le 5 ]; then
          SECURITY_SCORE="ACCEPTABLE"
          SECURITY_RATING="C"
        else
          SECURITY_SCORE="POOR"
          SECURITY_RATING="F"
        fi

        # ç”Ÿæˆç»¼åˆå®‰å…¨æŠ¥å‘Š
        cat > .github/security-reports/security-assessment.md << EOF
        # Comprehensive Security Assessment Report

        **Assessment Date:** $(date -u)
        **Version:** ${{ steps.next_version.outputs.new_version }}
        **Assessment Time:** ${SECURITY_TIME}s
        **Security Score:** $SECURITY_SCORE ($SECURITY_RATING)

        ## Security Overview
        - **Issues Found:** $ISSUE_COUNT
        - **Critical Issues:** $([ "$CRITICAL_VULNS" != "" ] && echo "$CRITICAL_VULNS" || echo "0")
        - **High Issues:** $([ "$HIGH_VULNS" != "" ] && echo "$HIGH_VULNS" || echo "0")
        - **Dependencies Scanned:** $([ "$VULNERABILITIES" != "unknown" ] && echo "$VULNERABILITIES vulnerabilities" || echo "Scan incomplete")

        ## Security Checklist
        ### Code Security âœ…
        - Hardcoded credentials check: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "credentials")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")
        - Environment variable safety: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "environment")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")
        - SQL injection protection: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "SQL")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")

        ### Build Security âœ…
        - Source map protection: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "Source maps")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")
        - Debug info removal: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "Debug")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")

        ### Infrastructure Security âœ…
        - Docker security: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "Docker")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")
        - Git security: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "Git")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")
        - Access control: $([ "$(echo "${SECURITY_ISSUES[@]}" | grep -c "permissions")" -eq 0 ] && echo "âœ… PASS" || echo "âŒ FAIL")

        ## Issues Found
        $(if [ "$ISSUE_COUNT" -eq 0 ]; then
          echo "ğŸ‰ No security issues found! Excellent security posture."
        else
          for issue in "${SECURITY_ISSUES[@]}"; do
            echo "- âš ï¸ $issue"
          done
        fi)

        ## Recommendations
        $([ "$ISSUE_COUNT" -gt 0 ] && echo "- Address the security issues listed above before deployment" || echo "- Security posture is excellent, safe to proceed")
        $([ "$CRITICAL_VULNS" -gt 0 ] && echo "- **CRITICAL**: Update dependencies with critical vulnerabilities immediately" || echo "- Dependencies are secure")
        $([ "$SECURITY_SCORE" = "POOR" ] && echo "- **ACTION REQUIRED**: Security review needed before production deployment" || echo "- Security review passed, ready for production")

        ## Security Metrics
        \`\`\`json
        {
          "assessmentTime": ${SECURITY_TIME},
          "issuesFound": $ISSUE_COUNT,
          "securityScore": "$SECURITY_SCORE",
          "rating": "$SECURITY_RATING",
          "criticalVulns": $([ "$CRITICAL_VULNS" != "" ] && echo "$CRITICAL_VULNS" || echo "0"),
          "highVulns": $([ "$HIGH_VULNS" != "" ] && echo "$HIGH_VULNS" || echo "0"),
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        \`\`\`
        EOF

        # 8. å®‰å…¨é—¨ç¦æ£€æŸ¥
        echo "ğŸš¦ æ‰§è¡Œå®‰å…¨é—¨ç¦æ£€æŸ¥..."

        if [ "$CRITICAL_VULNS" -gt 0 ]; then
          echo "ğŸš¨ ä¸¥é‡å®‰å…¨æ¼æ´æ£€æµ‹ï¼Œéƒ¨ç½²è¢«é˜»æ­¢"
          echo "SECURITY_GATE=BLOCKED" >> $GITHUB_ENV
          # ä¸é€€å‡ºï¼Œå…è®¸ç”ŸæˆæŠ¥å‘Š
        elif [ "$ISSUE_COUNT" -gt 10 ]; then
          echo "âš ï¸ å®‰å…¨é—®é¢˜è¿‡å¤šï¼Œå»ºè®®å®¡æŸ¥"
          echo "SECURITY_GATE=WARNING" >> $GITHUB_ENV
        else
          echo "âœ… å®‰å…¨é—¨ç¦é€šè¿‡"
          echo "SECURITY_GATE=PASSED" >> $GITHUB_ENV
        fi

        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        rm -f npm-audit.json

        echo "ğŸ”’ å®‰å…¨éªŒè¯å®Œæˆ (è¯„åˆ†: $SECURITY_RATING, è€—æ—¶: ${SECURITY_TIME}s)"

    - name: Install git-cliff
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        wget -q https://github.com/orhun/git-cliff/releases/download/v1.4.0/git-cliff-1.4.0-x86_64-unknown-linux-gnu.tar.gz
        tar -xzf git-cliff-1.4.0-x86_64-unknown-linux-gnu.tar.gz
        chmod +x git-cliff-1.4.0/git-cliff
        sudo mv git-cliff-1.4.0/git-cliff /usr/local/bin/

    - name: Generate changelog
      if: steps.check.outputs.needs_bump == 'true'
      id: changelog
      run: |
        # è·å–ä¸Šä¸€ä¸ªtagä»¥æ¥çš„æ›´æ–°æ—¥å¿—
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -n "$LATEST_TAG" ]; then
          # æ’é™¤VERSIONæ–‡ä»¶çš„æäº¤
          CHANGELOG=$(git-cliff --config .github/cliff.toml $LATEST_TAG..HEAD --strip header | grep -v "bump version" | sed '/^$/d' || echo "- ä»£ç ä¼˜åŒ–å’Œæ”¹è¿›")
        else
          CHANGELOG=$(git-cliff --config .github/cliff.toml --strip header || echo "- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ")
        fi
        echo "content<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create and push tag
      if: steps.check.outputs.needs_bump == 'true'
      run: |
        NEW_TAG="${{ steps.next_version.outputs.new_tag }}"
        git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
        git push origin HEAD:${{ github.ref_name }} "$NEW_TAG"

    - name: Create GitHub Release
      if: steps.check.outputs.needs_bump == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.next_version.outputs.new_tag }}
        name: Release ${{ steps.next_version.outputs.new_version }}
        body: |
          ## ğŸ³ Docker é•œåƒ

          ```bash
          docker pull ${{ secrets.DOCKERHUB_USERNAME || 'await2719' }}/meow-accounting:${{ steps.next_version.outputs.new_tag }}
          docker pull ${{ secrets.DOCKERHUB_USERNAME || 'await2719' }}/meow-accounting:latest
          ```

          ## ğŸ“¦ ä¸»è¦æ›´æ–°

          ${{ steps.changelog.outputs.content }}

          ## ğŸ“‹ å®Œæ•´æ›´æ–°æ—¥å¿—

          æŸ¥çœ‹ [æ‰€æœ‰ç‰ˆæœ¬](https://github.com/${{ github.repository }}/releases)
        draft: false
        prerelease: false
        generate_release_notes: true

    # è‡ªåŠ¨æ¸…ç†æ—§çš„tagså’Œreleasesï¼ˆä¿æŒæœ€è¿‘50ä¸ªï¼‰
    - name: Cleanup old tags and releases
      if: steps.check.outputs.needs_bump == 'true'
      continue-on-error: true
      env:
        TAGS_TO_KEEP: 50
      run: |
        echo "ğŸ§¹ è‡ªåŠ¨æ¸…ç†æ—§ç‰ˆæœ¬ï¼Œä¿æŒæœ€è¿‘ $TAGS_TO_KEEP ä¸ªtag..."

        # è·å–æ‰€æœ‰ç‰ˆæœ¬tagå¹¶æŒ‰ç‰ˆæœ¬å·æ’åºï¼ˆä»æ—§åˆ°æ–°ï¼‰
        echo "æ­£åœ¨è·å–æ‰€æœ‰tags..."
        ALL_TAGS=$(git ls-remote --tags origin | grep -E 'refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$' | awk '{print $2}' | sed 's|refs/tags/||' | sort -V)

        # æ£€æŸ¥æ˜¯å¦è·å–åˆ°tags
        if [ -z "$ALL_TAGS" ]; then
          echo "âš ï¸ æœªæ‰¾åˆ°ä»»ä½•ç‰ˆæœ¬tag"
          exit 0
        fi

        TOTAL_COUNT=$(echo "$ALL_TAGS" | wc -l)

        echo "ğŸ“Š å½“å‰tagç»Ÿè®¡ï¼š"
        echo "- æ€»æ•°: $TOTAL_COUNT"
        echo "- é…ç½®ä¿ç•™: $TAGS_TO_KEEP"

        if [ "$TOTAL_COUNT" -gt "$TAGS_TO_KEEP" ]; then
          DELETE_COUNT=$((TOTAL_COUNT - TAGS_TO_KEEP))
          echo "- å°†è¦åˆ é™¤: $DELETE_COUNT ä¸ªæœ€æ—§çš„tag"

          # è·å–è¦åˆ é™¤çš„tagsï¼ˆæœ€è€çš„ï¼‰
          TAGS_TO_DELETE=$(echo "$ALL_TAGS" | head -n "$DELETE_COUNT")

          # æ˜¾ç¤ºå°†è¦åˆ é™¤çš„ç‰ˆæœ¬èŒƒå›´
          OLDEST_TO_DELETE=$(echo "$TAGS_TO_DELETE" | head -1)
          NEWEST_TO_DELETE=$(echo "$TAGS_TO_DELETE" | tail -1)
          echo ""
          echo "ğŸ—‘ï¸ å°†è¦åˆ é™¤çš„ç‰ˆæœ¬èŒƒå›´ï¼š"
          echo "- ä»: $OLDEST_TO_DELETE"
          echo "- åˆ°: $NEWEST_TO_DELETE"

          echo ""
          echo "å¼€å§‹æ‰§è¡Œåˆ é™¤..."
          SUCCESS_COUNT=0
          FAIL_COUNT=0

          for tag in $TAGS_TO_DELETE; do
            echo -n "  åˆ é™¤ $tag ... "

            # å…ˆæ£€æŸ¥releaseæ˜¯å¦å­˜åœ¨
            if gh release view "$tag" >/dev/null 2>&1; then
              # Releaseå­˜åœ¨ï¼Œåˆ é™¤releaseä¼šåŒæ—¶åˆ é™¤tag
              if gh release delete "$tag" --yes --cleanup-tag 2>/dev/null; then
                echo "âœ… (release+tag)"
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                echo "âŒ (releaseåˆ é™¤å¤±è´¥)"
                FAIL_COUNT=$((FAIL_COUNT + 1))
              fi
            else
              # Releaseä¸å­˜åœ¨ï¼Œåªåˆ é™¤tag
              if git push origin --delete "$tag" 2>/dev/null; then
                echo "âœ… (ä»…tag)"
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                echo "â­ï¸ (å·²ä¸å­˜åœ¨)"
                FAIL_COUNT=$((FAIL_COUNT + 1))
              fi
            fi
          done

          echo ""
          echo "ğŸ“Š æ¸…ç†ç»“æœï¼š"
          echo "- æˆåŠŸåˆ é™¤: $SUCCESS_COUNT"
          echo "- å¤±è´¥/è·³è¿‡: $FAIL_COUNT"

          # é‡æ–°è·å–å¹¶æ˜¾ç¤ºä¿ç•™çš„ç‰ˆæœ¬èŒƒå›´
          echo ""
          echo "æ­£åœ¨éªŒè¯æ¸…ç†ç»“æœ..."
          REMAINING_TAGS=$(git ls-remote --tags origin | grep -E 'refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$' | awk '{print $2}' | sed 's|refs/tags/||' | sort -V)
          REMAINING_COUNT=$(echo "$REMAINING_TAGS" | wc -l)
          OLDEST=$(echo "$REMAINING_TAGS" | head -1)
          NEWEST=$(echo "$REMAINING_TAGS" | tail -1)

          echo "âœ… æ¸…ç†å®Œæˆï¼"
          echo ""
          echo "ğŸ“Œ å½“å‰ä¿ç•™çš„ç‰ˆæœ¬ï¼š"
          echo "- æœ€æ—§ç‰ˆæœ¬: $OLDEST"
          echo "- æœ€æ–°ç‰ˆæœ¬: $NEWEST"
          echo "- ç‰ˆæœ¬æ€»æ•°: $REMAINING_COUNT"

          # éªŒè¯æ˜¯å¦è¾¾åˆ°é¢„æœŸ
          if [ "$REMAINING_COUNT" -le "$TAGS_TO_KEEP" ]; then
            echo "- çŠ¶æ€: âœ… ç¬¦åˆé¢„æœŸï¼ˆâ‰¤$TAGS_TO_KEEPï¼‰"
          else
            echo "- çŠ¶æ€: âš ï¸ è¶…å‡ºé¢„æœŸï¼ˆæŸäº›tagå¯èƒ½åˆ é™¤å¤±è´¥ï¼‰"
          fi
        else
          echo "âœ… å½“å‰tagæ•°é‡ï¼ˆ$TOTAL_COUNTï¼‰æœªè¶…è¿‡é™åˆ¶ï¼ˆ$TAGS_TO_KEEPï¼‰ï¼Œæ— éœ€æ¸…ç†"
        fi

    # Dockeræ„å»ºæ­¥éª¤
    - name: Set up QEMU
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/login-action@v3
      with:
        registry: docker.io
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push Docker image
      if: steps.check.outputs.needs_bump == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: |
          ${{ secrets.DOCKERHUB_USERNAME }}/meow-accounting:${{ steps.next_version.outputs.new_tag }}
          ${{ secrets.DOCKERHUB_USERNAME }}/meow-accounting:latest
          ${{ secrets.DOCKERHUB_USERNAME }}/meow-accounting:${{ steps.next_version.outputs.new_version }}
        labels: |
          org.opencontainers.image.version=${{ steps.next_version.outputs.new_version }}
          org.opencontainers.image.revision=${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Send Telegram Notification
      if: steps.check.outputs.needs_bump == 'true' && env.TELEGRAM_BOT_TOKEN != '' && env.TELEGRAM_CHAT_ID != ''
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      continue-on-error: true
      run: |
        VERSION="${{ steps.next_version.outputs.new_version }}"
        TAG="${{ steps.next_version.outputs.new_tag }}"
        REPO="${{ github.repository }}"

        # è·å–æ›´æ–°å†…å®¹å¹¶é™åˆ¶é•¿åº¦
        CHANGELOG="${{ steps.changelog.outputs.content }}"
        CHANGELOG_TRUNCATED=$(echo "$CHANGELOG" | head -c 1000)
        if [ ${#CHANGELOG} -gt 1000 ]; then
          CHANGELOG_TRUNCATED="${CHANGELOG_TRUNCATED}..."
        fi

        # æ„å»ºæ¶ˆæ¯å†…å®¹
        MESSAGE="ğŸš€ *Meow Accounting æ–°ç‰ˆæœ¬å‘å¸ƒï¼*"$'\n'$'\n'
        MESSAGE+="ğŸ“¦ ç‰ˆæœ¬å·: \`${VERSION}\`"$'\n'$'\n'
        MESSAGE+="ğŸ“ *æ›´æ–°å†…å®¹:*"$'\n'
        MESSAGE+="${CHANGELOG_TRUNCATED}"$'\n'$'\n'
        MESSAGE+="ğŸ³ *Docker éƒ¨ç½²:*"$'\n'
        MESSAGE+="\`\`\`bash"$'\n'
        MESSAGE+="docker pull await2719/meow-accounting:${TAG}"$'\n'
        MESSAGE+="docker pull await2719/meow-accounting:latest"$'\n'
        MESSAGE+="\`\`\`"$'\n'$'\n'
        MESSAGE+="ğŸ”— *ç›¸å…³é“¾æ¥:*"$'\n'
        MESSAGE+="â€¢ [GitHub Release](https://github.com/${REPO}/releases/tag/${TAG})"$'\n'
        MESSAGE+="â€¢ [å®Œæ•´æ›´æ–°æ—¥å¿—](https://github.com/${REPO}/releases)"$'\n'
        MESSAGE+="â€¢ [Docker Hub](https://hub.docker.com/r/await2719/meow-accounting)"$'\n'$'\n'
        MESSAGE+="#MeowAccounting #Update #v${VERSION//./_}"

        # ä½¿ç”¨ jq æ„å»º JSON å¹¶å‘é€
        jq -n \
          --arg chat_id "${TELEGRAM_CHAT_ID}" \
          --arg text "${MESSAGE}" \
          '{
            chat_id: $chat_id,
            text: $text,
            parse_mode: "Markdown",
            disable_web_page_preview: false
          }' | \
        curl -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -H "Content-Type: application/json" \
          -d @-